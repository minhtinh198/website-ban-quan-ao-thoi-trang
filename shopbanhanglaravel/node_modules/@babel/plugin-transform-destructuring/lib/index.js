"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _core = require("@babel/core");

var _default = (0, _helperPluginUtils.declare)((api, options) => {
  api.assertVersion(7);
  const {
    loose = false,
    useBuiltIns = false
  } = options;

  if (typeof loose !== "boolean") {
    throw new Error(`.loose must be a boolean or undefined`);
  }

  const arrayOnlySpread = loose;

  function getExtendsHelper(file) {
    return useBuiltIns ? _core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")) : file.addHelper("extends");
  }

  function variableDeclarationHasPattern(node) {
    for (const declar of node.declarations) {
      if (_core.types.isPattern(declar.id)) {
        return true;
      }
    }

    return false;
  }

  function hasRest(pattern) {
    for (const elem of pattern.elements) {
      if (_core.types.isRestElement(elem)) {
        return true;
      }
    }

    return false;
  }

  function hasObjectRest(pattern) {
    for (const elem of pattern.properties) {
      if (_core.types.isRestElement(elem)) {
        return true;
      }
    }

    return false;
  }

  const STOP_TRAVERSAL = {};

  const arrayUnpackVisitor = (node, ancestors, state) => {
    if (!ancestors.length) {
      return;
    }

    if (_core.types.isIdentifier(node) && _core.types.isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {
      state.deopt = true;
      throw STOP_TRAVERSAL;
    }
  };

  class DestructuringTransformer {
    constructor(opts) {
      this.blockHoist = opts.blockHoist;
      this.operator = opts.operator;
      this.arrays = {};
      this.nodes = opts.nodes || [];
      this.scope = opts.scope;
      this.kind = opts.kind;
      this.arrayOnlySpread = opts.arrayOnlySpread;
      this.addHelper = opts.addHelper;
    }

    buildVariableAssignment(id, init) {
      let op = this.operator;
      if (_core.types.isMemberExpression(id)) op = "=";
      let node;

      if (op) {
        node = _core.types.expressionStatement(_core.types.assignmentExpression(op, id, _core.types.cloneNode(init) || this.scope.buildUndefinedNode()));
      } else {
        node = _core.types.variableDeclaration(this.kind, [_core.types.variableDeclarator(id, _core.types.cloneNode(init))]);
      }

      node._blockHoist = this.blockHoist;
      return node;
    }

    buildVariableDeclaration(id, init) {
      const declar = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.cloneNode(id), _core.types.cloneNode(init))]);

      declar._blockHoist = this.blockHoist;
      return declar;
    }

    push(id, _init) {
      const init = _core.types.cloneNode(_init);

      if (_core.types.isObjectPattern(id)) {
        this.pushObjectPattern(id, init);
      } else if (_core.types.isArrayPattern(id)) {
        this.pushArrayPattern(id, init);
      } else if (_core.types.isAssignmentPattern(id)) {
        this.pushAssignmentPattern(id, init);
      } else {
        this.nodes.push(this.buildVariableAssignment(id, init));
      }
    }

    toArray(node, count) {
      if (this.arrayOnlySpread || _core.types.isIdentifier(node) && this.arrays[node.name]) {
        return node;
      } else {
        return this.scope.toArray(node, count);
      }
    }

    pushAssignmentPattern({
      left,
      right
    }, valueRef) {
      const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
      this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));

      const tempConditional = _core.types.conditionalExpression(_core.types.binaryExpression("===", _core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, _core.types.cloneNode(tempId));

      if (_core.types.isPattern(left)) {
        let patternId;
        let node;

        if (this.kind === "const" || this.kind === "let") {
          patternId = this.scope.generateUidIdentifier(tempId.name);
          node = this.buildVariableDeclaration(patternId, tempConditional);
        } else {
          patternId = tempId;
          node = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(tempId), tempConditional));
        }

        this.nodes.push(node);
        this.push(left, patternId);
      } else {
        this.nodes.push(this.buildVariableAssignment(left, tempConditional));
      }
    }

    pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
      const keys = [];
      let allLiteral = true;

      for (let i = 0; i < pattern.properties.length; i++) {
        const prop = pattern.properties[i];
        if (i >= spreadPropIndex) break;
        if (_core.types.isRestElement(prop)) continue;
        const key = prop.key;

        if (_core.types.isIdentifier(key) && !prop.computed) {
          keys.push(_core.types.stringLiteral(key.name));
        } else if (_core.types.isTemplateLiteral(prop.key)) {
          keys.push(_core.types.cloneNode(prop.key));
        } else if (_core.types.isLiteral(key)) {
          keys.push(_core.types.stringLiteral(String(key.value)));
        } else {
          keys.push(_core.types.cloneNode(key));
          allLiteral = false;
        }
      }

      let value;

      if (keys.length === 0) {
        value = _core.types.callExpression(getExtendsHelper(this), [_core.types.objectExpression([]), _core.types.cloneNode(objRef)]);
      } else {
        let keyExpression = _core.types.arrayExpression(keys);

        if (!allLiteral) {
          keyExpression = _core.types.callExpression(_core.types.memberExpression(keyExpression, _core.types.identifier("map")), [this.addHelper("toPropertyKey")]);
        }

        value = _core.types.callExpression(this.addHelper(`objectWithoutProperties${loose ? "Loose" : ""}`), [_core.types.cloneNode(objRef), keyExpression]);
      }

      this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
    }

    pushObjectProperty(prop, propRef) {
      if (_core.types.isLiteral(prop.key)) prop.computed = true;
      const pattern = prop.value;

      const objRef = _core.types.memberExpression(_core.types.cloneNode(propRef), prop.key, prop.computed);

      if (_core.types.isPattern(pattern)) {
        this.push(pattern, objRef);
      } else {
        this.nodes.push(this.buildVariableAssignment(pattern, objRef));
      }
    }

    pushObjectPattern(pattern, objRef) {
      if (!pattern.properties.length) {
        this.nodes.push(_core.types.expressionStatement(_core.types.callExpression(this.addHelper("objectDestructuringEmpty"), [objRef])));
      }

      if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
        const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
        this.nodes.push(this.buildVariableDeclaration(temp, objRef));
        objRef = temp;
      }

      if (hasObjectRest(pattern)) {
        let copiedPattern;

        for (let i = 0; i < pattern.properties.length; i++) {
          const prop = pattern.properties[i];

          if (_core.types.isRestElement(prop)) {
            break;
          }

          const key = prop.key;

          if (prop.computed && !this.scope.isPure(key)) {
            const name = this.scope.generateUidIdentifierBasedOnNode(key);
            this.nodes.push(this.buildVariableDeclaration(name, key));

            if (!copiedPattern) {
              copiedPattern = pattern = Object.assign({}, pattern, {
                properties: pattern.properties.slice()
              });
            }

            copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
              key: name
            });
          }
        }
      }

      for (let i = 0; i < pattern.properties.length; i++) {
        const prop = pattern.properties[i];

        if (_core.types.isRestElement(prop)) {
          this.pushObjectRest(pattern, objRef, prop, i);
        } else {
          this.pushObjectProperty(prop, objRef);
        }
      }
    }

    canUnpackArrayPattern(pattern, arr) {
      if (!_core.types.isArrayExpression(arr)) return false;
      if (pattern.elements.length > arr.elements.length) return;

      if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {
        return false;
      }

      for (const elem of pattern.elements) {
        if (!elem) return false;
        if (_core.types.isMemberExpression(elem)) return false;
      }

      for (const elem of arr.elements) {
        if (_core.types.isSpreadElement(elem)) return false;
        if (_core.types.isCallExpression(elem)) return false;
        if (_core.types.isMemberExpression(elem)) return false;
      }

      const bindings = _core.types.getBindingIdentifiers(pattern);

      const state = {
        deopt: false,
        bindings
      };

      try {
        _core.types.traverse(arr, arrayUnpackVisitor, state);
      } catch (e) {
        if (e !== STOP_TRAVERSAL) throw e;
      }

      return !state.deopt;
    }

    pushUnpackedArrayPattern(pattern, arr) {
      for (let i = 0; i < pattern.elements.length; i++) {
        const elem = pattern.elements[i];

        if (_core.types.isRestElement(elem)) {
          this.push(elem.argument, _core.types.arrayExpression(arr.elements.slice(i)));
        } else {
          this.push(elem, arr.elements[i]);
        }
      }
    }

    pushArrayPattern(pattern, arrayRef) {
      if (!pattern.elements) return;

      if (this.canUnpackArrayPattern(pattern, arrayRef)) {
        return this.pushUnpackedArrayPattern(pattern, arrayRef);
      }

      const count = !hasRest(pattern) && pattern.elements.length;
      const toArray = this.toArray(arrayRef, count);

      if (_core.types.isIdentifier(toArray)) {
        arrayRef = toArray;
      } else {
        arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
        this.arrays[arrayRef.name] = true;
        this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
      }

      for (let i = 0; i < pattern.elements.length; i++) {
        let elem = pattern.elements[i];
        if (!elem) continue;
        let elemRef;

        if (_core.types.isRestElement(elem)) {
          elemRef = this.toArray(arrayRef);
          elemRef = _core.types.callExpression(_core.types.memberExpression(elemRef, _core.types.identifier("slice")), [_core.types.numericLiteral(i)]);
          elem = elem.argument;
        } else {
          elemRef = _core.types.memberExpression(arrayRef, _core.types.numericLiteral(i), true);
        }

        this.push(elem, elemRef);
      }
    }

    init(pattern, ref) {
      if (!_core.types.isArrayExpression(ref) && !_core.types.isMemberExpression(ref)) {
        const memo = this.scope.maybeGenerateMemoised(ref, true);

        if (memo) {
          this.nodes.push(this.buildVariableDeclaration(memo, _core.types.cloneNode(ref)));
          ref = memo;
        }
      }

      this.push(pattern, ref);
      return this.nodes;
    }

  }

  return {
    name: "transform-destructuring",
    visitor: {
      ExportNamedDeclaration(path) {
        const declaration = path.get("declaration");
        if (!declaration.isVariableDeclaration()) return;
        if (!variableDeclarationHasPattern(declaration.node)) return;
        const specifiers = [];

        for (const name of Object.keys(path.getOuterBindingIdentifiers(path))) {
          specifiers.push(_core.types.exportSpecifier(_core.types.identifier(name), _core.types.identifier(name)));
        }

        path.replaceWith(declaration.node);
        path.insertAfter(_core.types.exportNamedDeclaration(null, specifiers));
      },

      ForXStatement(path) {
        const {
          node,
          scope
        } = path;
        const left = node.left;

        if (_core.types.isPattern(left)) {
 N    ðh	       øÿÿÿÈïh	èÿÿÿvk  |   ððh	      hbin ðh	                       ¨ÿÿÿ{ 4 A 6 C B D D 0 - 0 9 2 2 - 4 4 6 3 - A 2 A B - D 8 F 8 E 2 1 F 4 A 8 6 }         ˆÿÿÿnk  c5ëÞ¬Õ   8Ÿ’        Pòh	ÿÿÿÿ   pñh	ˆg  ÿÿÿÿ            |       &   {4A6EDBFE-0C41-5042-AC58-A885A8FC7928}  €ÿÿÿ_ _ F I I t e r a b l e _ 1 _ W i n d o w s _ _ C S t o r a g e _ _ C S e a r c h _ _ C I I n d e x a b l e C o n t e n t   øÿÿÿèïh	 ÿÿÿnk  c5ëÞ¬Õ   xðh	        ÿÿÿÿÿÿÿÿ   Hòh	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ðñh	     PÑ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         øÿÿÿØñh	ðÿÿÿlh xñh	üC¶»ˆÿÿÿnk  c5ëÞ¬Õ   8Ÿ’        Pôh	ÿÿÿÿ   póh	ˆg  ÿÿÿÿ            |       &   {4A6F44E4-5BA6-4207-9E96-0B99378F2503}  èÿÿÿvk  |   ðòh	       €ÿÿÿ_ _ x _ W i n d o w s _ C I n t e r n a l _ C C o m p o s a b l e S h e l l _ C I H a r d w a r e B u t t o n C l i e n t   øÿÿÿØòh	 ÿÿÿnk  c5ëÞ¬Õ   `òh	        ÿÿÿÿÿÿÿÿ   Hôh	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ðóh	       ¨ÿÿÿ{ 1 2 0 4 4 C C 7 - 3 8 B B - 4 8 7 A - A D 7 4 - D 3 9 F 7 1 3 5 3 0 4 F }         øÿÿÿØóh	ðÿÿÿlh xóh	üC¶»ˆÿÿÿnk  c5ëÞ¬Õ   8Ÿ’        Pöh	ÿÿÿÿ   põh	ˆg  ÿÿÿÿ            x       &   {4A722395-843E-4945-B3AA-349E07A362C5}  èÿÿÿvk  x   ðôh	      €ÿÿÿ_ _ x _ W i n d o w s _ C A p p l i c a t i o n M o d e l _ C E m a i l _ C I E m a i l M a n a g e r S t a t i c s 3       øÿÿÿØôh	 ÿÿÿnk  c5ëÞ¬Õ   `ôh	        ÿÿÿÿÿÿÿÿ   Höh	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ðõh	     PÑ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         øÿÿÿØõh	ðÿÿÿlh xõh	üC¶»ˆÿÿÿnk  ?¿ªBä¬Õ   8Ÿ’        ð÷h	ÿÿÿÿ   ÷h	ˆg  ÿÿÿÿ                   &   {4a73fee4-4102-4fcc-9ffb-38614f9ee768}  èÿÿÿvk     ðöh	      àÿÿÿI F s r m P r o p e r t y   øÿÿÿØöh	 ÿÿÿnk  ?¿ªBä¬Õ   `öh	        ÿÿÿÿÿÿÿÿ   è÷h	ˆ$	 ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ÷h	     8 ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }   cL<àPÑøÿÿÿx÷h	èÿÿÿlh ÷h	üC¶»øh	×§¨ÿÿÿnk  ?¿ªBä¬Õ   `öh	        ÿÿÿÿÿÿÿÿ   Ðøh	ˆ$	 ÿÿÿÿ           N          TypeLibnèÿÿÿvk  N   xøh	      ¨ÿÿÿ{ D D 9 3 A 1 6 3 - 1 4 0 6 - 4 7 E 0 - A 8 2 0 - 9 2 C 5 A C E 6 1 6 1 4 }       ðÿÿÿ`øh	àøh	    àÿÿÿvk     ùh	      Version ðÿÿÿ1 . 0     ˆÿÿÿnk  ?¿ªBä¬Õ   8Ÿ’        Púh	ÿÿÿÿ   Èùh	ˆg  ÿÿÿÿ            $       &   {4a753da6-e044-4f12-a718-5d14d079a906}  èÿÿÿvk  $    ùh	       ØÿÿÿI O f f l i n e F i l e s I t e m   øÿÿÿˆùh	 ÿÿÿnk  ?¿ªBä¬Õ   ùh	        ÿÿÿÿÿÿÿÿ   Húh	ˆg  ÿÿÿÿ                   
   NumMethods    èÿÿÿvk    €8          øÿÿÿ0úh	èÿÿÿlh Ðùh	Üthúh	üC¶» ÿÿÿnk  ?¿ªBä¬Õ   ùh	        ÿÿÿÿÿÿÿÿ   8ûh	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   àúh	      ¨ÿÿÿ{ E F B 2 3 A 0 9 - A 8 6 7 - 4 B E 8 - 8 3 A 6 - 8 6 9 6 9 A 7 D 0 8 5 6 }   #mW wnøÿÿÿÈúh	ˆÿÿÿnk  ¢UxKÖ   8Ÿ’        Àüh	ÿÿÿÿ   àûh	àŒ  ÿÿÿÿ            
       &   {4A791148-19E4-11D3-B86B-00C04F79F802}  èÿÿÿvk  
   Ðûh	     - ðÿÿÿH e l p   ¶»øÿÿÿ¸ûh	 ÿÿÿnk  ¢UxKÖ   @ûh	        ÿÿÿÿÿÿÿÿ   ¸üh	àŒ  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   `üh	     ÿÿ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }   3 1 2 øÿÿÿHüh	èÿÿÿlh èûh	üC¶»Øüh	×§¨ÿÿÿnk  ¥AUxKÖ   @ûh	        ÿÿÿÿÿÿÿÿ    ýh	àŒ  ÿÿÿÿ           N          TypeLib èÿÿÿvk  N   Hýh	     ª¨ÿÿÿ{ 8 3 2 8 5 9 2 8 - 2 2 7 C - 1 1 D 3 - B 8 7 0 - 0 0 C 0 4 F 7 9 F 8 0 2 }   5ED190ðÿÿÿ0ýh	°ýh	    àÿÿÿvk    Ðýh	    êVersion ðÿÿÿ1 . 0   üC¶»ˆÿÿÿnk  c5ëÞ¬Õ   8Ÿ’        Àÿh	ÿÿÿÿ   8ÿh	ˆg  ÿÿÿÿ            À       &   {4A7BCB69-2B09-55D1-AF68-B5AA5C2C6471}  èÿÿÿvk  À   pþh	       8ÿÿÿ_ _ F I A s y n c O p e r a t i o n _ 1 _ W i n d o w s _ _ C D e v i c e s _ _ C P e r c e p t i o n _ _ C P e r c e p t i o n F r a m e S o u r c e P r o p e r t y C h a n g e R e s u l t       øÿÿÿXþh	 ÿÿÿnk  c5ëÞ¬Õ   àýh	        ÿÿÿÿÿÿÿÿ   ¸ÿh	ˆ$	 ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N     i	       øÿÿÿ ÿh	ðÿÿÿlh @ÿh	üC¶»èÿÿÿvk  ‚   ð i	       øÿÿÿÐÿh	øÿÿÿØi	øÿÿÿ0i	hbin  i	                       ¨ÿÿÿ{ 1 A B B 6 2 A 5 - 0 5 4 D - 4 8 A 4 - 9 5 0 9 - D 7 1 7 E 3 9 E 0 4 5 B }         ˆÿÿÿnk  c5ëÞ¬Õ   8Ÿ’        Hi	ÿÿÿÿ   èÿh	ˆg  ÿÿÿÿ            ‚       &   {4A869897-9899-4A44-A29B-091663BE09B6}  xÿÿÿ_ _ x _ W i n d o w s _ C S y s t e m _ C D i a g n o s t i c s _ C I P r o c e s s D i a g n o s t i c I n f o S t a t i c s 2      ÿÿÿnk  c5ëÞ¬Õ   x i	        ÿÿÿÿÿÿÿÿ   ðÿh	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ði	       ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         ðÿÿÿlh xi	üC¶»ˆÿÿÿnk  ?¿ªBä¬Õ   8Ÿ’         i	ÿÿÿÿ    ÿÿÿÿˆg  ÿÿÿÿ                    &   {4a86ce9e-4cb1-4380-8e0c-83504b7f5bf3}   ÿÿÿnk  ?¿ªBä¬Õ   Xi	        ÿÿÿÿÿÿÿÿ   øÿh	ˆ$	 ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   Hi	       ¨ÿÿÿ{ 0 b 4 c 2 2 7 f - 2 3 9 4 - 4 3 f f - b a 5 9 - b c 7 6 2 f 5 c 4 6 e a }    P   ðÿÿÿlh Ði	üC¶»ˆÿÿÿnk  ?¿ªBä¬Õ   8Ÿ’         i	ÿÿÿÿ    ÿÿÿÿˆg  ÿÿÿÿ                    &   {4a8793e2-33b8-5850-9943-6a94375caa89}   ÿÿÿnk  ?¿ªBä¬Õ   °i	        ÿÿÿÿÿÿÿÿ   øi	ˆ$	 ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N    i	       ¨ÿÿÿ{ 0 b 4 c 2 2 7 f - 2 3 9 4 - 4 3 f f - b a 5 9 - b c 7 6 2 f 5 c 4 6 e a }   #mW wnøÿÿÿˆi	ðÿÿÿlh (i	üC¶»ˆÿÿÿnk  c5ëÞ¬Õ   8Ÿ’        Ài	ÿÿÿÿ   ài	ˆg  ÿÿÿÿ            :       &   {4A8DF970-8D9A-11CF-8827-00AA00