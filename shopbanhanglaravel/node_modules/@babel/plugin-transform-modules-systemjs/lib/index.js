"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperHoistVariables = _interopRequireDefault(require("@babel/helper-hoist-variables"));

var _core = require("@babel/core");

var _utils = require("babel-plugin-dynamic-import-node/utils");

var _helperModuleTransforms = require("@babel/helper-module-transforms");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const buildTemplate = (0, _core.template)(`
  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {
    "use strict";
    BEFORE_BODY;
    return {
      setters: SETTERS,
      execute: function () {
        BODY;
      }
    };
  });
`);
const buildExportAll = (0, _core.template)(`
  for (var KEY in TARGET) {
    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];
  }
`);
const MISSING_PLUGIN_WARNING = `\
WARNING: Dynamic import() transformation must be enabled using the
         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will
         no longer transform import() without using that plugin.
`;

function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget) {
  const statements = [];

  if (exportNames.length === 1) {
    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));
  } else if (!exportStarTarget) {
    const objectProperties = [];

    for (let i = 0; i < exportNames.length; i++) {
      const exportName = exportNames[i];
      const exportValue = exportValues[i];
      objectProperties.push(_core.types.objectProperty(_core.types.identifier(exportName), exportValue));
    }

    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));
  } else {
    const exportObj = path.scope.generateUid("exportObj");
    statements.push(_core.types.variableDeclaration("var", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));
    statements.push(buildExportAll({
      KEY: path.scope.generateUidIdentifier("key"),
      EXPORT_OBJ: _core.types.identifier(exportObj),
      TARGET: exportStarTarget
    }));

    for (let i = 0; i < exportNames.length; i++) {
      const exportName = exportNames[i];
      const exportValue = exportValues[i];
      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));
    }

    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));
  }

  return statements;
}

var _default = (0, _helperPluginUtils.declare)((api, options) => {
  api.assertVersion(7);
  const {
    systemGlobal = "System",
    allowTopLevelThis = false
  } = options;
  const IGNORE_REASSIGNMENT_SYMBOL = Symbol();
  const reassignmentVisitor = {
    "AssignmentExpression|UpdateExpression"(path) {
      if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
      path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
      const arg = path.get(path.isAssignmentExpression() ? "left" : "argument");

      if (arg.isObjectPattern() || arg.isArrayPattern()) {
        const exprs = [path.node];

        for (const name of Object.keys(arg.getBindingIdentifiers())) {
          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {
            return;
          }

          const exportedNames = this.exports[name];
          if (!exportedNames) return;

          for (const exportedName of exportedNames) {
            exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);
          }
        }

        path.replaceWith(_core.types.sequenceExpression(exprs));
        return;
      }

      if (!arg.isIdentifier()) return;
      const name = arg.node.name;
      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
      const exportedNames = this.exports[name];
      if (!exportedNames) return;
      let node = path.node;
      const isPostUpdateExpression = path.isUpdateExpression({
        prefix: false
      });

      if (isPostUpdateExpression) {
        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression("+", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));
      }

      for (const exportedName of exportedNames) {
        node = this.buildCall(exportedName, node).expression;
      }

      if (isPostUpdateExpression) {
        node = _core.types.sequenceExpression([node, path.node]);
      }

      path.replaceWith(node);
    }

  };
  return {
    name: "transform-modules-systemjs",

    pre() {
      this.file.set("@babel/plugin-transform-modules-*", "systemjs");
    },

    visitor: {
      CallExpression(path, state) {
        if (_core.types.isImport(path.node.callee)) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
            console.warn(MISSING_PLUGIN_WARNING);
          }

          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("import")), [(0, _utils.getImportSource)(_core.types, path.node)]));
        }
      },

      MetaProperty(path, state) {
        if (path.node.meta.name === "import" && path.node.property.name === "meta") {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("meta")));
        }
      },

      ReferencedIdentifier(path, state) {
        if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("id")));
        }
      },

      Program: {
        enter(path, state) {
          state.contextIdent = path.scope.generateUid("context");

          if (!allowTopLevelThis) {
            (0, _helperModuleTransforms.rewriteThis)(path);
          }
        },

        exit(path, state) {
          const undefinedIdent = path.scope.buildUndefinedNode();
          const exportIdent = path.scope.generateUid("export");
          const contextIdent = state.contextIdent;
          const exportMap = Object.create(null);
          const modules = [];
          let beforeBody = [];
          const setters = [];
          const sources = [];
          const variableIds = [];
          const removedPaths = [];

          function addExportName(key, val) {
            exportMap[key] = exportMap[key] || [];
            exportMap[key].push(val);
          }

          function pushModule(source, key, specifiers) {
            let module;
            modules.forEach(function (m) {
              if (m.key === source) {
                module = m;
              }
            });

            if (!module) {
              modules.push(module = {
                key: source,
                imports: [],
                exports: []
              });
            }

            module[key] = module[key].concat(specifiers);
          }

          function buildExportCall(name, val) {
            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));
          }

          const exportNames = [];
          const exportValues = [];
          const body = path.get("body");

          for (const path of body) {
            if (path.isFunctionDeclaration()) {
              beforeBody.push(path.node);
              removedPaths.push(path);
            } else if (path.isClassDeclaration()) {
              variableIds.push(path.node.id);
              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));
            } else if (path.isImportDeclaration()) {
              const source = path.node.source.value;
              pushModule(source, "imports", path.node.specifiers);

              for (const name of Object.keys(path.getBindingIdentifiers())) {
                path.scope.removeBinding(name);
                variableIds.push(_core.types.identifier(name));
              }

              path.remove();
            } else if (path.isExportAllDeclaration()) {
              pushModule(path.node.source.value, "exports", path.node);
              path.remove();
            } else if (path.isExportDefaultDeclaration()) {
              const declar = path.get("declaration");
              const id = declar.node.id;

              if (declar.isClassDeclaration()) {
                if (id) {
                  exportNames.push("default");
                  exportValues.push(undefinedIdent);
                  variableIds.push(id);
                  addExportName(id.name, "default");
                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(id), _core.types.toExpression(declar.node))));
                } else {
                  exportNames.push("default");
                  exportValues.push(_core.types.toExpression(declar.node));
                  removedPaths.push(path);
                }
              } else if (declar.isFunctionDeclaration()) {
                if (id) {
                  beforeBody.push(declar.node);
                  exportNames.push("default");
                  exportValues.push(_core.types.cloneNode(id));
                  addExportName(id.name, "default");
                } else {
                  exportNames.push("default");
                  exportValues.push(_core.types.toExpression(declar.node));
                }

                removedPaths.push(path);
              } else {
                path.replaceWith(buildExportCall("default", declar.node));
              }
            } else if (path.isExportNamedDeclaration()) {
              const declar = path.get("declaration");

              if (declar.node) {
                path.replaceWith(declar);

                if (path.isFunction()) {
                  const node = declar.node;
                  const name = node.id.name;
                  addExportName(name, name);
                  beforeBody.push(node);
                  exportNames.push(name);
                  exportValues.push(_core.types.cloneNode(node.id));
                  removedPaths.push(path);
                } else if (path.isClass()) {
                  const name = declar.node.id.name;
                  exportNames.push(name);
                  exportValues.push(undefinedIdent);
                  variableIds.push(declar.node.id);
                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(declar.node.id), _core.types.toExpression(declar.node))));
                  addExportName(name, name);
                } else {
                  for (const name of Object.keys(declar.getBindingIdentifiers())) {
                    addExportName(name, name);
                  }
                }
              } else {
                const specifiers = path.node.specifiers;

                if (specifiers && specifiers.length) {
                  if (path.node.source) {
                    pushModule(path.node.source.value, "exports", specifiers);
                    path.remove();
                  } else {
                    const nodes = [];

                    for (const specifier of specifiers) {
                      const binding = path.scope.getBinding(specifier.local.name);

                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {
                ğnk	üC¶»èÿÿÿvk  B   ˜pk	      øÿÿÿØok	øÿÿÿ@qk	hbin pk	                       ˆÿÿÿnk  ù!ëŞ¬Õ   8Ÿ’        °qk	ÿÿÿÿ   ğok	ˆg  ÿÿÿÿ            B       &   {4D596E92-C4DC-4EA6-8D58-0242B14C90B3}  ¸ÿÿÿI M u l t i t a s k i n g V i e w D i s m i s s C a l l b a c k      ÿÿÿnk  ù!ëŞ¬Õ    pk	        ÿÿÿÿÿÿÿÿ   øok	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   Xqk	       ¨ÿÿÿ{ C 9 0 2 5 0 F 3 - 4 D 7 D - 4 9 9 1 - 9 B 6 9 - A 5 C 5 B C 1 C 2 A E 6 }         ğÿÿÿlh àpk	üC¶»ˆÿÿÿnk  şšëŞ¬Õ   8Ÿ’        èsk	ÿÿÿÿ   sk	ˆg  ÿÿÿÿ            ®       &   {4D5F57DF-E0DC-5CF5-B2E5-FA1E5C0006FA}  èÿÿÿvk  ®   Prk	       Hÿÿÿ_ _ F I A s y n c O p e r a t i o n C o m p l e t e d H a n d l e r _ 1 _ W i n d o w s _ _ C A p p l i c a t i o n M o d e l _ _ C E m a i l _ _ C E m a i l M a i l b o x         øÿÿÿ8rk	 ÿÿÿnk  ù!ëŞ¬Õ   Àqk	        ÿÿÿÿÿÿÿÿ   àsk	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ˆsk	       ¨ÿÿÿ{ 9 5 E 1 5 D 0 A - 6 6 E 6 - 9 3 D 9 - C 5 3 C - 7 6 E 6 2 1 9 D 3 3 4 1 }         øÿÿÿpsk	ğÿÿÿlh sk	üC¶»ˆÿÿÿnk  şšëŞ¬Õ   8Ÿ’        øuk	ÿÿÿÿ   uk	ˆg  ÿÿÿÿ            Œ       &   {4D65DD1E-93C2-4D8F-B017-11C62117DA09}  èÿÿÿvk  Œ   ˆtk	       pÿÿÿ_ _ x _ W i n d o w s _ C I n t e r n a l _ C U I _ C L o g o n _ C L o g o n U X _ C I R e q u e s t C r e d e n t i a l C o m p l e t e   øÿÿÿptk	 ÿÿÿnk  şšëŞ¬Õ   øsk	        ÿÿÿÿÿÿÿÿ   ğuk	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   ˜uk	       ¨ÿÿÿ{ 8 6 4 A 9 4 4 9 - 0 5 B 7 - 4 A 4 F - B 2 F B - 7 C B A C A 7 4 A 5 B 1 }         øÿÿÿ€uk	ğÿÿÿlh  uk	üC¶»ˆÿÿÿnk  şšëŞ¬Õ   8Ÿ’         wk	ÿÿÿÿ   Àvk	ˆg  ÿÿÿÿ            "       &   {4D65FD08-D13E-4274-9C8B-DD8D028C8644}  èÿÿÿvk  "   ˜vk	      ØÿÿÿI U P n P A s y n c R e s u l t     øÿÿÿ€vk	 ÿÿÿnk  şšëŞ¬Õ   vk	        ÿÿÿÿÿÿÿÿ   ˜wk	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   @wk	     8 ¨ÿÿÿ{ 0 0 0 2 0 4 2 4 - 0 0 0 0 - 0 0 0 0 - C 0 0 0 - 0 0 0 0 0 0 0 0 0 0 4 6 }         øÿÿÿ(wk	èÿÿÿlh Èvk	üC¶»¸wk	×§¨ÿÿÿnk  şšëŞ¬Õ   vk	        ÿÿÿÿÿÿÿÿ   €xk	ˆg  ÿÿÿÿ           N          TypeLib èÿÿÿvk  N   (xk	      ¨ÿÿÿ{ D B 3 4 4 2 A 7 - A 2 E 9 - 4 A 5 9 - 9 C B 5 - F 5 C 1 A 5 D 9 0 1 E 5 }         ğÿÿÿxk	xk	    àÿÿÿvk    °xk	      Version ğÿÿÿ1 . 0       ˆÿÿÿnk  şšëŞ¬Õ   8Ÿ’        €zk	ÿÿÿÿ    yk	ˆg  ÿÿÿÿ            J       &   {4D682BCE-A5D6-47E6-A236-CFDE5FBDF2ED}  èÿÿÿvk  J   Pyk	       °ÿÿÿI X b o x L i v e Q u a l i t y O f S e r v i c e M e a s u r e m e n t     øÿÿÿ8yk	 ÿÿÿnk  şšëŞ¬Õ   Àxk	        ÿÿÿÿÿÿÿÿ   xzk	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N    zk	       ¨ÿÿÿ{ 2 C F D 5 F 1 D - B F A A - 4 B 7 2 - B 0 3 5 - 6 B 6 9 1 F 3 A 2 0 4 C }         øÿÿÿzk	ğÿÿÿlh ¨yk	üC¶»ˆÿÿÿnk  şšëŞ¬Õ   8Ÿ’        ˆ|k	ÿÿÿÿ   ¨{k	ˆg  ÿÿÿÿ            ~       &   {4D6F5451-DC8B-5FC0-9C5F-76E3F07EB2EA}  èÿÿÿvk  ~    {k	       xÿÿÿI I t e r a b l e _ 1 _ W i n d o w s _ _ C D e v i c e s _ _ C P o i n t O f S e r v i c e _ _ C P a y m e n t M e t h o d         øÿÿÿ{k	 ÿÿÿnk  şšëŞ¬Õ   zk	        ÿÿÿÿÿÿÿÿ   €|k	ˆ$	 ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   (|k	     —ñ¨ÿÿÿ{ E 1 B A 8 8 B A - 7 A 8 3 - 4 2 1 A - A 0 5 D - 7 1 F 9 6 C 3 F F F D 0 }         øÿÿÿ|k	ğÿÿÿlh °{k	üC¶»ˆÿÿÿnk  şšëŞ¬Õ   8Ÿ’        @~k	ÿÿÿÿ   `}k	ˆg  ÿÿÿÿ            4       &   {4D725739-9AA4-4006-BBBE-109CC5A9A68A}  èÿÿÿvk  4   (}k	       ÈÿÿÿI R e s e t U s e r P r o f i l e C a l l b a c k   øÿÿÿ}k	 ÿÿÿnk  şšëŞ¬Õ   ˜|k	        ÿÿÿÿÿÿÿÿ   8~k	ˆg  ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N   à}k	       ¨ÿÿÿ{ C 9 0 2 5 0 F 3 - 4 D 7 D - 4 9 9 1 - 9 B 6 9 - A 5 C 5 B C 1 C 2 A E 6 }         øÿÿÿÈ}k	ğÿÿÿlh h}k	üC¶»ˆÿÿÿnk  şšëŞ¬Õ   8Ÿ’         €k	ÿÿÿÿ    k	ˆg  ÿÿÿÿ            :       &   {4D73BC8F-FB53-4EB2-985F-1D91DE0B7639}  èÿÿÿvk  :   à~k	       ÀÿÿÿI P r i n t B o r d e r i n g O p t i o n D e t a i l s     øÿÿÿÈ~k	 ÿÿÿnk  şšëŞ¬Õ   P~k	        ÿÿÿÿÿÿÿÿ   øk	ˆ$	 ÿÿÿÿ            N          ProxyStubClsid32èÿÿÿvk  N    k	     PÑ¨ÿÿÿ{ 7 E 1 A 1 F A 9 - E F 4 F - 4 1 E 6 - 8 F 9 5 - 6 8 4 E D 5 0 E 0 3 9 A }         øÿÿÿˆk	hbin €k	                       ğÿÿÿlh (k	üC¶»ˆÿÿÿnk  !Ğ‡@Ö   8Ÿ’        àk	ÿÿÿÿ    k	àŒ  ÿÿÿÿ            6       &   {4D773761-0AD4-11D2-BF01-00A0C95A6A5C}  èÿÿÿvk  6   À€k	  